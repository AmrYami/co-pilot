"""Utilities for extracting and validating SQL generated by the LLM."""

from __future__ import annotations

import re
from typing import Iterable, Sequence

__all__ = ["extract_sql", "validate_sql"]

_FENCE_RE = re.compile(r"```(?:sql)?\s*(.*?)```", re.S | re.I)
_SQL_START_RE = re.compile(r"(?is)\b(SELECT|WITH)\b")
_HAS_FROM_RE = re.compile(r"(?is)\bFROM\b")
_PROMPT_ECHO_RE = re.compile(r"(?is)\b(Return|Fix|Answer with|SQL:)\b")


def extract_sql(text: str) -> str:
    """Return SQL from ``text`` if present.

    Preference order:
    1. Content inside the first ```sql fenced block.
    2. First occurrence of SELECT/WITH and onward.
    """

    if not text:
        return ""

    match = _FENCE_RE.search(text)
    if match:
        return match.group(1).strip()

    match = _SQL_START_RE.search(text)
    if not match:
        return ""
    return text[match.start() :].strip()


def _find_binds(sql: str) -> list[str]:
    return re.findall(r":([a-zA-Z_][\w]*)", sql)


def validate_sql(
    sql: str,
    *,
    allow_tables: Sequence[str] | None = None,
    allow_binds: Iterable[str] | None = None,
) -> tuple[bool, list[str], list[str]]:
    """Perform lightweight validation on the generated SQL.

    Returns a tuple ``(ok, errors, binds)`` where ``binds`` is the list of
    bind names referenced in ``sql``. ``allow_tables`` defaults to ("Contract",).
    """

    errors: list[str] = []
    binds: list[str] = []

    if not sql or not sql.strip():
        return False, ["empty_sql"], []

    stripped = sql.strip()

    if not _SQL_START_RE.match(stripped):
        errors.append("not_select")

    # Detect prompt echoes (Return Oracle SQL..., etc.)
    head = stripped[:80]
    if _PROMPT_ECHO_RE.search(head):
        errors.append("prompt_echo")

    if not _HAS_FROM_RE.search(stripped):
        errors.append("missing_from")

    allowed_tables = tuple(allow_tables) if allow_tables else ("Contract",)
    has_table = False
    for table in allowed_tables:
        quoted = f'"{table}"'
        if quoted in stripped:
            has_table = True
            break
        table_re = re.compile(rf"(?is)\bFROM\s+{re.escape(table)}\b")
        if table_re.search(stripped):
            has_table = True
            break
    if not has_table:
        errors.append("missing_allowed_table")

    if allow_binds is not None:
        allow = set(allow_binds)
        binds = _find_binds(stripped)
        illegal = sorted({b for b in binds if b not in allow})
        if illegal:
            errors.append("illegal_binds:" + ",".join(illegal))
    else:
        binds = _find_binds(stripped)

    return not errors, errors, binds
